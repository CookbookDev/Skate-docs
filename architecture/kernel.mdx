---
title: "Kernel Layer"
description: "An in-depth view of Kernel Layer"
---

<Note>
This document assumes a prerequisite understanding of the Skate Architecture, which can be found [here](/architecture/skate#skates-kernel-and-periphery)
</Note>

## Kernel Components

The kernel reside on Skate Chain, consisting of 2 core components:

1. **Message Box**<br/> 
  A single contract that defines interface for _all Skate Apps_ to register user intent and corresponding execution tasks. It serves as the entry point for creating intents, and all executors will source this contract for pending actions.

1. **Skate App**<br/>
  The base contract that all kernel implementations must inherit from. Skate App has the responsbility to: 
    + Defining the interface for executors to reserve execution of intents.
    + Transforming user intents to imperative tasks for executions.
    + Pushing relevant data into Message Box.
    + Link the kernel app to all periphery apps on destination chains.

An overview of the interaction with Kernel is shown in the diagram below:

<Card title="Kernel Flow Diagram">

```mermaid
  flowchart TB
    executor[Any Executor] -- "call with user signed intent" --> skateApp

    subgraph kernel[A Kernel]
      f0["Arbitrary private \napplication specific logics"]
      state[(App Shared State)]
      subgraph skateApp[Skate App]
        processIntent["ProcessIntent()"]
      end
      processIntent -- internal call --> f0
      processIntent -- stage --> state
    end
    
    processIntent -- parse intent calldata --> submitTask

    subgraph MB[Message Box]
      submitTask["SubmitTasks()"]
      taskStore[("Task Store \n(create pending tasks)")]

      submitTask -- dump --> taskStore
      submitTask -- register --> regExecution["Task <-> Executor \nmapping"]
    end
```
</Card>

In addition, an Executor Registry will live on Skate to register actors with the capability to process user intents. For in-depth details, refer to [execution network](/architecture/execution-network)
