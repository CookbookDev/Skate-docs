---
title: "Kernel Layer"
description: "An in-depth view of Kernel Layer"
---

<Note>
This document assumes a prerequisite understanding of the Skate Architecture, which can be found [here](/main/architecture/skate#skates-kernel-and-periphery)
</Note>

## Kernel Components

The kernel reside on Skate Chain, consisting of 2 core components:

1. **Message Box**<br/> 
  A single contract that defines interface for _all Skate Apps_ to register user intent and corresponding execution tasks. It serves as the entry point for creating intents, and all executors will source this contract for pending actions.

1. **Skate App**<br/>
  The base contract that all kernel implementations must inherit from. Skate App has the responsbility to: 
    + Defining the interface for executors to reserve execution of intents.
    + Transforming user intents to imperative tasks for executions.
    + Pushing relevant data into Message Box.
    + Link the kernel app to all periphery apps on destination chains.

An overview of the interaction with Kernel is shown in the diagram below:

<Card title="Kernel Flow Diagram">

```mermaid
  flowchart BT
    executor[Any Executor] -- "parse user signed intent" --> processIntent

    subgraph kernel[App Kernel]
      f0["Arbitrary application \nspecific logics"]
      state[(App Shared State)]
      subgraph skateApp[SkateApp]
        processIntent{{"ProcessIntent()"}}
      end
      processIntent -- execute --> f0
      processIntent -- stage --> state
    end
    
    processIntent -- parse intent calldata --> submitTask

    subgraph MB[Message Box]
      submitTask{{"SubmitTasks()"}}
      taskStore[("Task Store \n(pending tasks)")]

      submitTask -- update --> taskStore
      submitTask -- register --> regExecution["Task <-> Executor\n mapping"]
    end
```
</Card>

In addition, an Executor Registry will live on Skate to register actors with the capability to process user intents. For in-depth details, refer to [execution network](/main/architecture/execution-network)
